\section{Einleitung}
\label{sec:einleitung}
Die Repräsentation und Manipulation von Booleschen Funktionen ist bedeutsam für Algorithmen in Applikationen. Somit können Probleme bei dem Very-Large-Scale-Integration (VLSI) CAD, d.\,h. computergestützten Schaltkreisentwurf, als Sequenz von Operationen über eine Menge von Booleschen Funktionen ausgedrückt werden. Beispiele hierfür sind unter anderem die kombinatorische Logik-Verifikation \cite{mwbs1988},  symbolische Simulation \cite{c1988} und das Model Checking \cite{rk2017}.\\
Es ist daher erstrebenswert, ein Softwarepaket zu entwickeln, das die Erstellung von Variablen als auch Operationen wie \texttt{and}, \texttt{or}, \texttt{not} usw. auf Funktionen erlaubt. Zudem sollte das Paket auch u.\,a. einen Tautologietest, d.\,h. eine immer wahr berechnende Funktion für alle Eingaben gewährleisten (siehe Kapitel \ref{sec:tautologietest} auf Seite \pageref{sec:tautologietest}). Der Tautologietest ist co-NP-vollständig, d.\,h. das Komplement liegt in der Klasse NP (siehe Kapitel \ref{sec:formal} auf Seite \pageref{sec:formal}). Diese enthält alle Entscheidungsprobleme, die von einer nichtdeterministischen Turingmaschine (NTM) hinsichtlich der Eingabelänge in Polynomialzeit gelöst werden können. Ist ein solcher Algorithmus nicht effizient implementiert, so kann die Berechnung aller bekannten Lösungen eine gewisse Zeit erfordern, die mit der Anzahl von Variablen im Worst Case exponentiell wächst.\\
Es ist also ratsam, eine durchdachte Repräsentation und effiziente Algorithmen zur Manipulation zu wählen, um diesen Fall zu verhindern. Werden bspw. zur Darstellung Boolescher Funktionen Normalformen wie die Disjunktive Normalform (DNF) oder Konjunktive Normalform (KNF) verwendet, so haben einige Funktionen eine exponentielle Größe \cite{bmhs1984}. Sie sind weiterhin nur für wenige Eingänge einsetzbar, da sie viel Speicherplatz benötigen \cite[S.394-395]{h2014}. Um eine arbiträre Kompaktheit sowie Effizienz der Manipulation zu gewährleisten, gibt es ein Binäres Entscheidungsdiagramm (BDD) bzw. Branchingprogramm (BP), das gut erforscht ist \cite[S.227-240]{fhs1978}. BDDs sind eine heuristische Methode, um eine große Menge an Zuständen zu repräsentieren und sind typischerweise übersichtlich, wenn der Zustandsraum Symmetrien enthält. Dies ist genau dann der Fall, wenn ein System ähnliche Module enthält. Zu erwähnen ist, dass BDDs in einigen, aber nicht in allen Fällen effizienter als bspw. Wertetabellen sind \cite[S.46]{s2007}.\\
Um z.\,B. die Tautologie in konstanter Zeit berechnen zu können, wird die Kanonizität benötigt, d.\,h. eine eindeutige Darstellung, die ein reduzierter geordneter BDD (ROBDD) bietet. Somit muss nur ein ROBDD zu der untersuchenden Funktion erstellt und mit $1$ bzw. $0$ verglichen werden. Durch die Kanonizität wird ebenfalls der Äquivalenztest bzw. Test auf Erfüllbarkeit problemlos möglich (siehe Kapitel \ref{sec:verifikation} ab Seite \pageref{sec:verifikation}), wozu lediglich die ROBDDs auf Isomorphie geprüft werden müssen bzw. nachgeschaut werden muss, ob die Wurzel das 0-Blatt ist. Darüber hinaus ist es für ein allgemeines BDD unklar, wie eben genannte Operationen \texttt{and} etc. effizient realisiert werden können \cite{g2002}. Für ein ROBDD sind diese - wegen Einschränkungen - hingegen polynomiell beschränkt. Zu beachten ist, dass die Größe eines ROBDD im Worst Case ebenfalls exponentiell sein kann, was von der Variablenordnung abhängt, die optimal gewählt werden muss (siehe Kapitel \ref{sec:ordnung} ab Seite \pageref{sec:ordnung}).\\
Hinzuzufügen ist, dass es bereits einige BDD-Pakete wie CUDD\footnote{CUDD, \url{http://vlsi.colorado.edu/~fabio/}} oder CacBDD\footnote{CacBDD, \url{http://www.kailesu.net/CacBDD/}} gibt, die jedoch auch Schwachstellen aufweisen \cite{rk2017}. So konnte bspw. beim Model Checking mit der webbasierten Schnittstelle \glqq IscasMC\grqq{} herausgefunden werden, dass eine arbiträre Abhängigkeit zum Model besteht, was sich wiederum auf die Performanz von BDD-Paketen auswirkt. Das Ziel ist es daher, ein generisches Paket zu erstellen, das -- von der Berechnung als auch dem Speicherverhalten her -- effizient ist. In dieser Arbeit wird eine dementsprechende Implementierung eines ROBDD-Paketes mit verschiedenen Hashtabellen und komplementären Kanten beschrieben, die in Kapitel \ref{sec:implementierung} ab Seite \pageref{sec:implementierung} ersichtlich ist. Die dazu benötigten Grundlagen werden in Kapitel \ref{sec:bdd_grundlagen} ab Seite \pageref{sec:bdd_grundlagen} erklärt. Anschließend erfolgt die Erläuterung zu einer Implementierung eines neuen Ansatzes, um die Kollisionsbehandlung in einer Hashtabelle durchzuführen, der in Kapitel \ref{sec:verkettung} ab Seite \pageref{sec:verkettung} zu finden ist.