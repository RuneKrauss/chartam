\section{Introduction}
\label{sec:introduction}
Compilers are programs that transform a source language into a lower target language. A source program and a compiler serve as input. Afterwards, the execution takes place on a machine. On the other hand, an interpreter translates command by command and executes them directly on the machine. However, a compiler is faster because no interpreter has to be active at runtime and it can be optimized better but it is more difficult to implement. An example of a compiled language is C++\footnote{C++, \url{http://www.cplusplus.com}}. Another example of an interpreted language is Python\footnote{Python, \url{https://www.python.org}}.

This paper deals with the implementation of a platform-independent compiler for a language called \emph{E}. ANother Tool for Language Recognition (ANTLR), an object-oriented parser generator, is used for this purpose. Of course, there are already several compilers like C++ or Fortran\footnote{Fortran, \url{http://www.fortran.de}}. However, there are several reasons why new compilers also make sense. On the one hand, a new way of thinking is to be tried out. Haskell\footnote{Haskell, \url{http://www.haskell.org}} investigated e.g. laziness in the language or BASIC\footnote{BASIC, \url{http://www.media.salford-systems.com/pdf/spm7/BasicProgLang.pdf}} wanted to make learning easier for programmers. Here, conventional language properties are to be removed as far as possible until a Turing machine-like language remains whereby the compiler is kept small. Furthermore, the language concept is kept very simple so that a lot can be described with as little expression as possible without limiting the universal readiness for use. Finally, concepts for application-oriented languages will be demonstrated. For example, these include loops and conditions. The goal is to explicitly promote structural thinking. During the implementation, special attention is paid to how trees are traversed efficiently so that the code can be generated optimally.

The compiler is designed according to various quality criteria. It must deliver correct results and react to any operating errors with a well-defined state. Furthermore there should be an understandable user documentation and the source code should be readable. Ultimately, another goal is portability on multiple systems. Software tests are used to detect and localize errors and contribute to quality assurance. Specifically, module tests and integration tests are used. Thus modules are also examined together.

The explanation of the compiler is based on the respective compiler phases which are subdivided into an analysis and synthesis (see chapter \ref{sec:compiler_phases} on page \pageref{sec:compiler_phases}). With regard to analysis, this concerns lexical, syntax and context analysis. The code generation is about generating assembler-like instructions. Furthermore, the module and integration tests are explained in chapter \ref{sec:tests} on page \pageref{sec:tests} to investigate the quality of the compiler.