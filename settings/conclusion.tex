\newpage
\section{Summary and Conclusion}
\label{sec:summary_conclusion}

In this paper the development of an own language \emph{E} or the corresponding platform-independent compiler was described. This concerns both analysis and synthesis (see figure \ref{fig:compiler_phases} on page \pageref{fig:compiler_phases}). The focus was on traversing the AST (see chapter \ref{sec:context_analysis} on page \pageref{sec:context_analysis}) and code generation (see chapter \ref{sec:code_generation} on page \pageref{sec:code_generation}). Accordingly, the source code is translated into byte code after traversing (to exclude type errors, etc.) and can be executed in the JVM. The aim was to be able to describe a lot with as few expressions as possible and to demonstrate different constructs. In addition, conventional language properties should be removed until a Turing machine-like language remains. Various unit and integration tests should ensure the quality of the compiler.

The language \emph{E} supports different data types (see chapter \ref{sec:lexical_analysis} on page \pageref{sec:lexical_analysis}) like booleans, integers, floating point numbers, strings, arrays and objects as well as different commands (see chapter \ref{sec:syntactic_analysis} on page \pageref{sec:syntactic_analysis}). This includes functions, structures and different statements like branches, loops, variables and inline assembler. These are separated so that global visibility is also possible. Thus e.g. function definitions or structure declarations can stand below their use. Through the use of while loops, the language is even Turing complete, thus providing universal programmability. The system and a universal Turing machine can thus emulate each other or each program part can be converted into a different language and vice versa. Since the libraries provided are still restrictive, it is possible to program different routines with inline assembly, e.g. in dealing with file systems (see appendix on page \pageref{lst:inlineAsm}).

TDD was used as the development process (see figure \ref{fig:tdd} on page \pageref{fig:tdd}). Various tests (see chapter \ref{sec:tests} on page \pageref{sec:tests}) check the correctness of the provided constructs. This refers to the direct application as well as the interaction between different components. For example, branches can also be used in loops. Furthermore, a static code analysis was performed to find possible errors such as unreachable code. This procedure was repeated until all tests were successful (see figure \ref{fig:tests} on page \pageref{fig:tests}).

Finally, it should be said that optimized code is produced in relation to the realized language constructs (see appendix from page \pageref{lst:eprogram}) and all known possible programming errors are found by the lexer, parser and context analysis. Also a possible conversion to interpretation would be possible. It would be conceivable, for example, that a generic data type instead of a string would be used as the return value of the visitor methods (see code \ref{lst:visitor} on page \pageref{lst:visitor}). Thus, individual data types can be set and checked. Output then takes place, for example, directly in Java. Also a flexible further development of the language constructs is given by the ease of maintenance.